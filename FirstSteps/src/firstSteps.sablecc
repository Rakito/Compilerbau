Helpers
 digit = ['0' .. '9'];
 letter = ['a' .. 'z'] | ['A' .. 'Z'];
 any_charater = [0x0 .. 0xfffff];

 

Tokens
 
 define = 'define';
 func = 'func';
 begin = 'begin';
 end = 'end';
 cons = 'cons';
 where = 'where';
 break = 'break';
 true = 'TRUE';
 false ='FALSE';
 returnt = 'return';
 null = 'null';
 
 id = letter ( digit | letter )*;
 number = digit+;
 plus = '+';
 hyphen = '-';
 asterisk = '*';
 percent = '%';
 dot = '.';
 comma = ',';
 query ='?';
 colon = ':';
 semicolon = ';';
 l_box = '[';
 r_box = ']';
 l_par = '(';
 r_par = ')';
 l_brace = '{';
 r_brace = '}';
 l_arrow = '<';
 r_arrow = '>';
 blank = (' ')*;
 dash = '-';
 ampersand = '&';
 slash = '/';
 question = '?';
 exclamation = '!';
 at = '@';
 tilde = '~';
 section = '¤';
 underscore = '_';
 pipe = '|';
 hash = '#';
 caret = '^';
 degree = '¡';
 blackslash ='\';
 equals = '=';
 quote = '"';
 
 return = ( 13 | 10 );
 comment = 'ÚÚ' any_charater;
 



Ignored Tokens
 comment, blank ;
 
 

Productions

 define = 
  {define} T.define id equals term |
  {function} T.func l_arrow [return]:id r_arrow [name]:id l_par term r_par impl |
  {cons} T.cons id l_par term r_par impl |
  {nil} T.cons id l_par r_par impl ;
  
 impl =
  {expr} l_brace [impl]:expr T.return [returnex]:expr r_brace |
  {implexpr} l_brace impl comma [implex]:expr T.return [returnex]:expr r_brace ;

 expr = 
  {term} term |
  {function} function |
  {plus} expr plus term |
  {minus} expr dash term |
  {mult} expr asterisk term |
  {div} expr slash term |
  {mod} expr percent term |
  {if} [if]:expr query [then]:term colon [else]:term |
  {concat} [left]:expr comma [right]:term ;
  
 function = 
  {func_call} id l_par term r_par ;

 term = 
  {id} id |
  {number} number |
  {null} T.null |
  {expr} l_par expr r_par ;
   
   

