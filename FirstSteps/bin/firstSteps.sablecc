Helpers
 digit = ['0' .. '9'];
 letter = ['a' .. 'z'] | ['A' .. 'Z'];
 any_character = [0x0 .. 0xfffff];
 true = 'TRUE';
 false ='FALSE';
 cstart = 'nativC>';
 cend = '<nativC';
 

Tokens
 
 define = 'define';
 func = 'func';
 begin = 'begin';
 end = 'end';
 cons = 'cons';
 where = 'where';
 break = 'break'; 
 returnt = 'return';
 null = 'null';

 call = 'call';
 bool = true | false;
 
 id = letter ( digit | letter )*;
 number = digit+;
 plus = '+';
 hyphen = '-';
 asterisk = '*';
 percent = '%';
 dot = '.';
 comma = ',';
 query ='?';
 colon = ':';
 semicolon = ';';
 l_box = '[';
 r_box = ']';
 l_par = '(';
 r_par = ')';
 l_brace = '{';
 r_brace = '}';
 l_arrow = '<';
 r_arrow = '>';
 blank = (' ')*;
 dash = '-';
 ampersand = '&';
 slash = '/';
 question = '?';
 exclamation = '!';
 at = '@';
 tilde = '~';
 section = '¤';
 underscore = '_';
 pipe = '|';
 hash = '#';
 caret = '^';
 degree = '¡';
 blackslash ='\';
 equals = '=';
 quote = '"';

 ccode = cstart ( any_character )* cend;
 
 return = ( 13 | 10 );
 tab = 9 ;
 comment = 'ÚÚ' any_character;
 
 endoffile = 4 ;


Ignored Tokens
 comment, blank, tab, return ;
 
 

Productions

 program = 
  {eof} T.end |
  {function} function |
  {define} P.define program ;

 define = 
  {define} T.define id equals term |
  {function} T.func l_arrow [return]:id r_arrow [name]:id l_par term r_par l_brace impl |
  {cons} T.cons id l_par term r_par l_brace impl |
  {nil} T.cons id l_par r_par l_brace impl ;
  
  
 impl =
  {end} r_brace |
  {return} T.returnt expr r_brace |
  {expr} expr impl |
  {define} P.define impl ;
  

 expr = 
  {end} expr hash |
  {term} term |
  {nativc} ccode |
  {function} function |
  {plus} expr plus term |
  {minus} expr dash term |
  {mult} expr asterisk term |
  {div} expr slash term |
  {mod} expr percent term |
  {if} [if]:expr query [thenin]:l_brace [then]:impl colon [elsein]:l_brace [else]:impl |
  {concat} [left]:expr comma [right]:term ;
  
 function = 
  {func_call} T.call id l_par expr r_par ;

 term = 
  {id} id |
  {number} number |
  {null} T.null |
  {bool} T.bool |
  {expr} l_par expr r_par ;
   
   

